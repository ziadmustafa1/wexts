// A very basic regex-based parser to demonstrate the "Auto Linking" concept
// In a real Node.js environment, this would use ts-morph or typescript API

export const simulateCodegen = (sourceCode: string): string => {
  let output = `// @fusion/api-client/generated.ts\n// AUTO-GENERATED BY FUSION CLI - DO NOT EDIT\n\nimport { apiFetcher as fetcher } from './fetcher';\nimport type { Todo, CreateTodoDto } from '@fusion/types';\n\nexport const api = {\n`;
  
  const controllerRegex = /@Controller\(['"](.+?)['"]\)/g;
  
  // Find controllers
  let controllerMatch;
  while ((controllerMatch = controllerRegex.exec(sourceCode)) !== null) {
    const basePath = controllerMatch[1];
    output += `  ${basePath}: {\n`;

    // Reset method regex lastIndex to search within the controller (roughly)
    
    let methodMatch;
    // Regex to capture Decorator, Args, MethodName, ReturnType (optional)
    const localMethodRegex = /@(Get|Post|Put|Delete|Patch)\(['"]?([^'"]*)['"]?\)\s+(?:async\s+)?(\w+)\s*\(([^)]*)\)(?:\s*:\s*Promise<([^>]+)>)?/g;

    while ((methodMatch = localMethodRegex.exec(sourceCode)) !== null) {
        const httpMethod = methodMatch[1].toLowerCase(); // get, post
        const subPath = methodMatch[2] ? `/${methodMatch[2]}` : ''; // /:id or empty
        const funcName = methodMatch[3]; // findAll
        const args = methodMatch[4]; // args string
        const returnType = methodMatch[5] || 'any'; // Todo[] or any

        // Determine if body is present (naive check)
        const hasBody = args.includes('@Body');
        const hasParam = args.includes('@Param');
        
        let funcSignature = '';
        let fetchCall = '';

        if (hasBody && (httpMethod === 'post' || httpMethod === 'put' || httpMethod === 'patch')) {
            // Extract DTO type if possible
            const bodyMatch = /@Body\(\)\s*\w+:\s*(\w+)/.exec(args);
            const dtoType = bodyMatch ? bodyMatch[1] : 'any';
            
            funcSignature = `(dto: ${dtoType})`;
            fetchCall = `fetcher.${httpMethod}<${returnType}>('/${basePath}${subPath}', dto)`;
        } else if (hasParam) {
            // Try to extract param name
            const paramMatch = /@Param\(['"](\w+)['"]\)\s+(\w+)/.exec(args);
            const paramName = paramMatch ? paramMatch[2] : 'id';
             // If path has :id, we need to replace it. simplified logic:
            funcSignature = `(${paramName}: string)`;
            const finalPath = subPath.includes(':') ? `/${basePath}${subPath.replace(/:(\w+)/, `\${${paramName}}`)}` : `/${basePath}${subPath}`;
            fetchCall = `fetcher.${httpMethod}<${returnType}>(\`${finalPath}\`)`;
        } else {
            funcSignature = '()';
            fetchCall = `fetcher.${httpMethod}<${returnType}>('/${basePath}${subPath}')`;
        }

        output += `    ${funcName}: ${funcSignature} => ${fetchCall},\n`;
    }
    
    output += `  },\n`;
  }
  
  output += `};\n`;
  return output;
};